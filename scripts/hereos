#!/usr/bin/env python
"""HereOS SDK script

   Very basic initial script for HereOS SDK
"""

import getopt
import sys
import io
import os
import shutil
import subprocess
import shlex
import traceback
import yaml

class TColors:
    """Terminal color constant strings"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def usage():
    """Print usage information"""
    print "Welcome to the HereOS SDK"
    print ""
    print "Usage: hereos [--help|-h|--version|-v] [COMMAND]"
    print "\tinit <path>\tInitializes a new HereOS project at the specified path"
    print "\tlist-services\tShows a list of available microsservices and their installation status"
    print "\tenable-service <service_name>\tAdds microservice to the current project's build"
    print "\tcreate-service <service_name>\tCreates a new microservice and adds it to the build"
    print "\tdisable-service <service_name>\tRemoves microservice from the current project's build"
    print "\tbuild\tBuilds a device image"
    print "\trunqemu\tLaunches a local instance of QEMU running the built image"
    print "\tdeploy\tDeploys the built image to the current device (if OTA is enabled)"
    print ""

class NotAProjectFolder(Exception):
    """Raise this when trying to execute project commands from outside a project directory"""

def version():
    """Print the version string"""
    print "HereOS Version: 0.0.1\n"

def project_yocto_path():
    """Return the path for the yocto build environment"""
    project_path = find_project_path()
    return os.path.join(project_path, "yocto")

def project_yocto_env_path():
    """Return the path for the project-specific yocto env file"""
    project_path = find_project_path()
    return os.path.join(project_path, "config", "yocto-env.yaml")

def write_project_yocto_env(env, cwd=None):
    """Write the yocto env to disk"""
    old_cwd = None
    if cwd != None:
        old_cwd = os.getcwd()
        os.chdir(cwd)
    try:
        with io.open(project_yocto_env_path(), "w") as yaml_file:
            yaml_file.write(unicode(yaml.dump(env, default_flow_style=False)))
    finally:
        if old_cwd != None:
            os.chdir(old_cwd)

def load_project_yocto_env():
    """Loads the yocto environment for the current project"""
    return yaml.load(io.open(project_yocto_env_path(), "r"))

def project_services_config_path():
    """Return the path for the project-specific config file"""
    project_path = find_project_path()
    return os.path.join(project_path, "config", "services.yaml")

def list_services():
    """Print a list of available SDK services
       If executed from a HereOS project folder, will include information about the active
       services in this project
    """
    project = False
    try:
        services_config_path = project_services_config_path()
        project = True
    except NotAProjectFolder:
        services_config_path = os.path.join(sdk_config_folder(), "services.yaml")

    if project:
        print "Available microservices in the current project:\n"
    else:
        print "Available microservices in the HereOS SDK:\n"

    for service in yaml.load(io.open(services_config_path, "r")):
        if "enabled" in service:
            marker = "*"
        else:
            marker = ""
        print "\t%s%s\t%s" % (marker, service["name"], service["description"])
    print ""

def load_service_config(service_name):
    """Loads the config object for a particular service in the current project"""
    return [service for service in load_project_config() if service["name"] == service_name][0]

def load_project_config():
    """Loads the config object for the current project"""
    return yaml.load(io.open(project_services_config_path(), "r"))

def write_service_config(service_config):
    """Writes the config object for a particular service in the current project"""
    config = [s for s in load_project_config() if s["name"] != service_config["name"]]
    config.append(service_config)
    write_project_config(config)

def write_project_config(config):
    """Writes the config object to the project config file"""
    with io.open(project_services_config_path(), "w") as yaml_file:
        yaml_file.write(unicode(yaml.dump(config, default_flow_style=False)))

def add_service_to_project(service_name, description, version_string):
    """Adds a service to the current project config"""
    config = load_project_config()
    config.append({"name": service_name, "description": description, "version": version_string})
    write_project_config(config)

def enable_service(service_name):
    """Enables a service for building in the current image"""
    config = load_service_config(service_name)
    config["enabled"] = True
    write_service_config(config)

def disable_service(service_name):
    """Enables a service for building in the current image"""
    config = load_service_config(service_name)
    config.pop("enabled", None)
    write_service_config(config)

def sdk_config_folder():
    """Returns the path to the SDK config folder"""
    return os.path.join(sdk_folder(), "config")

def sdk_folder():
    """Returns the path to the folder where the SDK is installed"""
    return os.path.realpath(os.path.join(os.path.dirname(__file__), ".."))

def find_project_path():
    """Searches the directory tree upwards to find the project above CWD
       Raises a NotAProjectFolder error if no project is found
    """
    path = os.getcwd()
    while path != '/':
        if os.path.exists(os.path.join(path, ".hereos_project")):
            return path
        else:
            path = os.path.realpath(os.path.join(path, ".."))
    raise NotAProjectFolder

def init_yocto_project(path):
    """Initializes a default Yocto project in the current folder"""
    try:
        if not os.path.exists(path):
            os.makedirs(path)

        print "Checking out 'updater' yocto project to %s" % path
        print TColors.OKBLUE
        process = subprocess.Popen(["repo", "init", "-u",
                                    "https://github.com/advancedtelematic/updater-repo.git"],
                                   cwd=path, shell=False)
        process.wait()
        print TColors.ENDC
        if process.returncode != 0:
            print "Error cloning repo project. Check internet connection"
            sys.exit(process.returncode)

        print "Syncing repo..."
        print TColors.OKBLUE
        process = subprocess.Popen(["repo", "sync"], cwd=path, shell=False)
        process.wait()
        print TColors.ENDC
        if process.returncode != 0:
            print "Error syncing repo. Check internet connection"
            sys.exit(process.returncode)

        print "Extracting yocto environment"
        command = shlex.split(("env -i bash -c "
                               "'source meta-updater/scripts/envsetup.sh "
                               "qemux86-64 >/dev/null 2>&1 && env'"))
        process = subprocess.Popen(command, cwd=path, stdout=subprocess.PIPE)
        env = {}
        for line in process.stdout:
            (key, _, value) = line.partition("=")
            env[key] = value.strip()
        process.communicate()
        write_project_yocto_env(env, cwd=path)

    finally:
        print TColors.ENDC

def init_sdk_project(path):
    """Creates a new SDK project in the current working directory"""
    print "SDK folder: %s" % sdk_folder()
    target = path if os.path.isabs(path) else os.path.join(os.getcwd(), path)

    # Create target folder
    print "Creating project target folder: %s" % target
    try:
        os.makedirs(target)
    except OSError as err:
        print "Error creating project folder: '%s'" % format(err)
        print "Check permissions and try again"
        sys.exit(2)

    # Create folder structure
    os.mkdir(os.path.join(target, "config"))

    # Copy default config
    shutil.copyfile(os.path.join(sdk_config_folder(), "services.yaml"),
                    os.path.join(target, "config", "services.yaml"))

    # Create project marker
    open(os.path.join(target, ".hereos_project"), 'a').close()

    init_yocto_project(os.path.join(target, "yocto"))

def project_services_path():
    """Returns the location of the services path for the current project
       Raises a NotAProjectFolder error if not in a project folder
    """
    return os.path.join(find_project_path(), "services")

def create_service(service_name):
    """Creates a new microservice from the microservice template"""

    # Create the top-level project services folder unless it exists
    try:
        if not os.path.exists(project_services_path()):
            os.makedirs(project_services_path())
    except NotAProjectFolder:
        print "Unable to create a new service - not in a HereOS project folder"
        sys.exit(2)
    service_path = os.path.join(project_services_path(), service_name)

    # Copy the template project to the new service folder
    print "Creating new HereOS template service at: %s" % service_path
    shutil.copytree(os.path.join(sdk_folder(), "service_template"), service_path)

    # Register the service with the current project and enable it
    add_service_to_project(service_name, "Template microservice", "0.0.1")
    enable_service(service_name)

def merge_paths(orig, priority):
    """Merges the contents of two paths variables"""
    orig_elements = orig.split(":")
    priority_elements = priority.split(":")
    new_elements = []
    for element in priority_elements:
        if element not in orig_elements:
            new_elements.append(element)
    return new_elements.extend(orig_elements)

def get_yocto_environment():
    """Fetches yocto environment and returns it as a dictionary"""
    yocto_env = os.environ.copy()
    yocto_env["PATH"] = merge_paths(os.environ["PATH"], yocto_env["PATH"])
    yocto_env.update(load_project_yocto_env())
    return yocto_env

def runqemu():
    """Runs a build qemu image"""
    yocto_env = get_yocto_environment()
    print "Running QEMU Image - login with username 'root'"
    try:
        print TColors.OKBLUE
        process = subprocess.Popen(["runqemu", "qemux86"],
                                   cwd=os.path.join(project_yocto_path(), "build"),
                                   env=yocto_env)
        process.wait()
        if process.returncode != 0:
            print "Error launching qemu: %s" % process.returncode

    finally:
        print TColors.ENDC

def build_image():
    """Kicks off a bitbake build"""
    yocto_env = get_yocto_environment()
    print "Bitbaking in: %s" % os.path.join(project_yocto_path(), "build")
    process = subprocess.Popen(["bitbake", "core-image-minimal"],
                               cwd=os.path.join(project_yocto_path(), "build"),
                               env=yocto_env)
    process.wait()
    if process.returncode != 0:
        print "Error running Yocto build: %s" % process.returncode

def main():
    """Main entry point for CLI"""
    if len(sys.argv) == 1:
        usage()
        sys.exit()

    # Process option arguments
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "version"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print str(err)
        usage()
        sys.exit(2)
    for opt, args in opts:
        if opt in ("-v", "--version"):
            version()
            sys.exit()
        elif opt in ("-h", "--help"):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option: %s, %s" % (opt, args)

    # Switch on main command
    try:
        {
            'create-service':  lambda x: create_service(*x),
            'disable-service': lambda x: disable_service(*x),
            'enable-service':  lambda x: enable_service(*x),
            'init':            lambda x: init_sdk_project(*x),
            'build':           lambda x: build_image(*x),
            'list-services':   lambda x: list_services(),
            'runqemu':         lambda x: runqemu()
        }[args[0]](args[1:])
    except KeyError as err:
        print "Unknown command: '%s' (%s)\n" % (args[0], err)
        traceback.print_exception(*sys.exc_info())
        usage()
        sys.exit(2)

if __name__ == "__main__":
    main()

# vim: tabstop=4 shiftwidth=4 expandtab
